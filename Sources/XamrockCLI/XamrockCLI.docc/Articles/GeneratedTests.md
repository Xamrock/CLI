# Generated Tests

Understanding the test suite created by Xamrock explorations.

## Overview

When you run an exploration, Xamrock generates a comprehensive test suite based on what it discovered in your app. This guide explains the structure and content of these generated tests.

## File Structure

After running an exploration test, you'll find:

```
scout-results/
├── ScoutCLIExploration.swift           # Test you added to Xcode (generated by CLI)
└── 2025-10-27_23-34-49_ABC123/         # Results from test run
    ├── GeneratedTests.swift             # Complete test suite (8+ tests)
    ├── FailureReport.md                 # Issues found
    └── dashboard.html                   # Visual report
```

## Test File Types

### 1. ScoutCLIExploration.swift (CLI Generated)

This is the test file you add to your Xcode project. It contains:

```swift
import XCTest

@available(iOS 26.0, *)
final class ScoutCLIExploration: XCTestCase {
    func testExploration() throws {
        let app = XCUIApplication()
        app.launch()

        let config = ExplorationConfig(
            steps: 20,
            goal: "Explore the app systematically",
            outputDirectory: URL(fileURLWithPath: "./scout-results"),
            generateTests: true,
            generateDashboard: true,
            failOnCriticalIssues: false,
            verboseOutput: false
        )

        let result = try Scout.explore(app, config: config)
        XCTAssertGreaterThan(result.stepsCompleted, 0)
    }
}
```

**Key Points:**
- One-time setup: Add this to your project
- Configurable: Modify settings without regenerating
- Reusable: Run multiple times to explore your app

### 2. GeneratedTests.swift (Runtime Generated)

Created when the exploration test runs. Contains specific tests for discovered functionality:

```swift
import XCTest

@available(iOS 26.0, *)
final class GeneratedExplorationTests: XCTestCase {

    // MARK: - Authentication Tests

    func testLoginFlow() throws {
        let app = XCUIApplication()
        app.launch()

        // AI-discovered login sequence
        app.buttons["Sign In"].tap()
        app.textFields["Email"].tap()
        app.textFields["Email"].typeText("test@example.com")
        // ... more steps
    }

    func testLogoutFlow() throws {
        // AI-discovered logout sequence
        // ...
    }

    // MARK: - Navigation Tests

    func testHomeToProfile() throws {
        // AI-discovered navigation path
        // ...
    }

    // MARK: - Data Entry Tests

    func testFormValidation() throws {
        // AI-discovered form validation
        // ...
    }

    // ... 5-10+ additional tests
}
```

## Test Categories

Generated tests are organized into categories based on discovered functionality:

### Authentication & Onboarding
- Login/logout flows
- Sign-up processes
- Password reset
- Onboarding screens

### Navigation
- Tab bar navigation
- Deep linking paths
- Modal presentations
- Back navigation

### Data Entry
- Form validation
- Text input
- Date/time pickers
- Multi-step forms

### Content Display
- List scrolling
- Detail views
- Empty states
- Loading states

### User Actions
- Button interactions
- Gestures (swipe, long-press)
- Pull-to-refresh
- Search functionality

### Error Handling
- Offline states
- Invalid input handling
- Permission requests
- Error messages

## Test Quality

Generated tests include:

### Assertions

```swift
XCTAssertTrue(app.buttons["Submit"].exists)
XCTAssertEqual(app.textFields.count, 3)
XCTAssertTrue(app.staticTexts["Welcome"].waitForExistence(timeout: 5))
```

### Waiters

```swift
let element = app.buttons["Load More"]
XCTAssertTrue(element.waitForExistence(timeout: 10))
```

### Comments

```swift
// Navigate to settings screen
app.tabBars.buttons["Settings"].tap()

// Verify settings loaded
XCTAssertTrue(app.navigationBars["Settings"].exists)
```

## Using Generated Tests

### Option 1: Copy Individual Tests

Extract specific tests from `GeneratedTests.swift`:

```bash
# View generated tests
cat scout-results/*/GeneratedTests.swift

# Copy desired tests to your test suite
# Add them to your existing test classes
```

### Option 2: Import Entire File

Add the entire `GeneratedTests.swift` to your Xcode project:

1. Drag the file into your UITests target
2. Run with `⌘U` to execute all tests

### Option 3: Use as Reference

Use generated tests as a starting point:

1. Review the test structure
2. Adapt to your naming conventions
3. Add custom assertions
4. Enhance with test data

## Failure Report

The `FailureReport.md` documents issues found:

```markdown
# Exploration Failure Report

## Summary
- Duration: 3m 42s
- Steps Completed: 20/20
- Critical Issues: 0
- Warnings: 3

## Issues Found

### Accessibility Issues

1. **Missing Label** (Screen: Profile)
   - Element: UIButton at (120, 340)
   - Issue: Button has no accessibility label
   - Recommendation: Add label for screen readers

2. **Low Contrast** (Screen: Settings)
   - Element: Text "Tap to edit"
   - Issue: Contrast ratio 2.8:1 (minimum 4.5:1)
   - Recommendation: Increase text darkness

### Navigation Issues

3. **Dead End** (Screen: Help)
   - Issue: No way to return to previous screen
   - Recommendation: Add back button or swipe gesture
```

## Dashboard

The `dashboard.html` provides visual representation:

- **Screenshots**: Every screen discovered
- **Navigation Map**: Visual graph of app structure
- **Test Coverage**: Percentage of screens tested
- **Issue Highlights**: Visual indicators of problems
- **Interaction Timeline**: Sequence of actions taken

## Customizing Test Generation

Control test generation via configuration:

```swift
let config = ExplorationConfig(
    steps: 30,
    goal: "Focus on checkout flow",
    outputDirectory: URL(fileURLWithPath: "./scout-results"),
    generateTests: true,        // Enable/disable test generation
    generateDashboard: true,    // Enable/disable dashboard
    failOnCriticalIssues: true, // Fail if critical issues found
    verboseOutput: true         // Detailed logging
)
```

## Best Practices

### 1. Review Before Committing

Always review generated tests before adding to version control:

```bash
# Review test structure
cat scout-results/*/GeneratedTests.swift

# Check for sensitive data
grep -i "password\|secret\|token" scout-results/*/GeneratedTests.swift
```

### 2. Enhance Tests

Add assertions and validations:

```swift
// Generated test
app.buttons["Submit"].tap()

// Enhanced version
app.buttons["Submit"].tap()
XCTAssertTrue(app.alerts["Success"].waitForExistence(timeout: 5))
XCTAssertEqual(app.alerts.element.label, "Form submitted successfully")
```

### 3. Parameterize Tests

Convert to data-driven tests:

```swift
func testFormValidation(email: String, expectedResult: Bool) {
    // Use generated test as template
    // Add parameterization
}
```

### 4. Organize by Feature

Group tests logically:

```swift
// MARK: - Authentication
func testLogin() { /* ... */ }
func testLogout() { /* ... */ }

// MARK: - Profile Management
func testEditProfile() { /* ... */ }
func testUpdateAvatar() { /* ... */ }
```

## Interpreting Results

### Success Indicators

- All steps completed
- No critical issues
- High coverage percentage
- Diverse screen discovery

### Warning Signs

- Repeated screens (stuck in loop)
- Low step completion
- Many critical issues
- Limited navigation discovery

## Next Steps

- Review <doc:Configuration-article> for test generation options
- Learn <doc:CI-Integration> for automated test runs
- Check <doc:Troubleshooting> if tests fail
